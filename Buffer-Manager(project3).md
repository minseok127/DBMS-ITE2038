Buffer Manager   
==============
디스크 I/O를 최소화 하기위해 Index 계층과 Disk 계층 사이에 위치하게 되는 계층입니다.   
     
해당 계층의 역할은 다음과 같습니다.   
1. 메모리 상에 페이지를 저장하여 해당 페이지에 대한 read가 생길 시 디스크가 아니라 메모리에서 불러오는 역할을 해주는 caching   
2. 페이지에 대한 수정을 할 때 디스크를 바로 수정하지 않고 버퍼를 수정함으로써 Index 계층이 디스크 입력을 기다리지 않고 다음 행동 수행 가능
   
본 프로젝트에서는 c++언어를 사용하여 구현하였고 리눅스 환경에서 g++ 7.5.0로 컴파일되었습니다.
  
Features
========
[1. Buffer Manager API](#buffer-manager-api)
   
[2. File Manager API modification](#file-manager-api-modification)
   
[3. Index Manager Command modification](#index-manager-command-modification)
   
## Buffer Manager API
+ Introduce
+ Header File
+ API

> ### Introduce
Buffer Manager는 API의 작동을 위해 크게 4가지의 객체를 이용하게 됩니다.     
    
+ #### Buffer 배열   
페이지들을 메모리 상에 저장할 Buffer Structure들의 배열입니다.   
유저가 Buffer Manager의 API 중 하나인 init_db함수(링크걸기)를 통해 동적할당하여 생성하게 됩니다.   
   
그림 넣고   

+ #### LRU_HEAD, LRU_TAIL (LRU LIST)   
이번 디자인에서는 페이지 eviction을 위해 LRU policy를 사용합니다.      
이를 위해 Buffer 배열의 논리적인 구조를 Double Linked List 형태로 생각할 것이고 이를 제어하기 위해 사용되는 객체들입니다.   
   
기본 구조 그림 넣어주고   
   
버퍼에 새로운 페이지가 들어오게 된다면 LRU_HEAD의 next가 해당 페이지를 가리키게 됩니다.   
   
그림 넣고   
   
이미 버퍼에 존재하던 페이지에 재접근 시에는 해당 페이지를 LRU LIST에서 뽑아낸 뒤 LRU_HEAD의 next로 보냅니다.   
   
그림 넣고   
   
버퍼에 존재하지 않는 페이지를 읽어야 하는데 버퍼에 자리가 없다면 LRU policy에 따라서 LRU_TAIL의 prev를 eviction하게 됩니다.   
   
그림 넣고   
   
만약 해당 prev의 pin이 0이 아니라면 LRU LIST를 순회하면서 eviction할 버퍼의 위치를 찾습니다.   
   
그림 넣고   
   
그리고 이러한 LRU LIST의 제어들에는 insert_into_LRUList, remove_from_LRUList, get_from_LRUList(링크걸어주고 3개 다) 이라는 함수들이 사용됩니다.   

+ #### 해쉬 객체   
해쉬 객체는 버퍼 내에서 특정 페이지가 어느 위치에 있는 지 파악하기 위해 쓰이는 객체입니다.    
     
init_db(링크걸기)를 호출하면 테이블 id마다 해쉬 객체가 할당됩니다. 내부에는 해쉬 테이블과 이 테이블 안에 어떤 페이지들이 있는 지 알 수 있는 리스트가 존재합니다.   
   
해쉬 테이블은 버퍼의 개수만큼의 칸을 가지고 chaining hash 디자인을 사용합니다. 또한 해쉬 함수로 나머지가 사용됩니다.   
예를 들어 버퍼의 개수가 100개라는 가정하에, 1058이라는 페이지 번호는 해쉬테이블에서 58번 자리에 위치하게 됩니다.   
   
해쉬 테이블에 대해서 해당 객체는 find, insert, delete (이것들도 다 링크 걸기)함수를 사용할 수 있습니다.   
   
find함수(링크)를 통해 해당 테이블에 대해서 유저가 원하는 페이지가 존재하는 버퍼의 위치를 파악합니다.   
   
그림 넣기   
   
insert함수(링크)를 통해서는 해쉬 객체에 새로운 페이지를 추가하게 됩니다. 
   
그림 넣기   
   
delete함수(링크)를 통해 해쉬 객체에 존재하는 페이지를 해쉬 테이블에서 제외시킵니다.   
   
그림 넣기
   
추가로 객체 내부에는 해쉬 테이블뿐만 아니라 테이블 안에 무슨 페이지들이 들어있는 지를 알 수 있도록 리스트가 존재합니다.   
이러한 리스트를 유지하는 이유는 특정 테이블 id만 flush시키는 것을 효율적으로 진행하기 위함입니다.   
   
만약 이러한 리스트가 없다면   
   
1. 버퍼 전체를 순회하며 해당 테이블 id인지 확인하며 flush시키는 것   
2. 해당 테이블 id를 담당하는 해쉬테이블 전체를 순회하며 버퍼를 flush시키는 것   
      
이러한 상황을 생각할 수 있습니다. 그러나 만약 사용자가 여럿이고 pin이 0이 아닌 버퍼들이 존재한다면   
한번의 순회 후에 어떤 페이지가 버퍼안에 추가로 생겼을 지 모르기 때문에 처음부터 다시 순회를 시작해야하고 이는 시간적인 비용이 커집니다.   
   
하지만 특정 테이블 id만 flush를 시키는 것이 흔히 발생하는 동작이 아니라서 리스트를 유지하는 비용이 더 커질 수 있다는 점을 고려해야합니다.    
그렇기에 리스트를 유지하는데 드는 비용을 최소화 시키는 것에 대한 설명을 하겠습니다.   
   
##### 1. 정렬되지 않은 배열로 유지   
리스트를 정렬되지 않은 배열로 유지시킨다면 insert(링크)를 수행할 때는 배열의 마지막에 추가하기만 하기 때문에 시간적 비용은 O(1)입니다.      
그러나 delete(링크)를 수행할 때는 해당하는 페이지의 위치를 모르기 때문에 O(N)의 비용이 발생합니다.   
또한 하나의 테이블 id가 버퍼 전체를 차지할 수 있기 때문에 배열의 크기가 버퍼의 개수와 같아야한다는 점에서 공간적인 비용도 커집니다.   
##### 2. 정렬된 배열로 유지   
리스트를 정렬된 상태로 유지시킨다면 insert(링크)를 수행할 때 이진 탐색을 통해 해당 페이지가 들어가야할 위치를 찾아야 합니다.   
이에 따르는 시간적 비용은 O(logN)이고, 그 뒤에 있는 값들을 한칸씩 밀어야 하기 때문에 추가적인 시간적 비용이 발생합니다.   
delete(링크)또한 insert(링크)와 같습니다.   
공간적인 비용의 문제는 1번에서 해결되지 않았습니다.   
##### 3. b+tree 형태로 유지   
해쉬 테이블 내에 존재하는 페이지들을 b+tree형태로 저장하는 디자인입니다.    
하나의 노드 당 최대 들어갈 수 있는 페이지의 수를 (버퍼의 개수/테이블의 수)로 설정한다면 공간적인 비용을 해결할 수 있습니다.   
그러나 insert와 delete에서의 시간적 비용은 2번에서 더 나아지지 않았습니다.   
##### 4. Double Linked List 형태로 유지   



> ### Header File
   
> ### API
   
## File Manager API modification
+ Introduce
+ Modification
## Index Manager Command modification
+ Introduce
+ Modification